[[\
  import urllib, os.path
  # The child variable is automatically injected into a parent template's context.
  # it contains the '_body' key which holds any text generated by the child,
  # as well as any other (string) keys passed as attributes to the spy:parent tag.
  # These may be accessed as child['foo'] or child.foo.
  L = child.get('extracode', []) 
  L.append(('parent template', request.filename()))

  # check the filesystem to see if we're running with the SF cgi file layout
  cwd = os.path.dirname(request.stack()[-1])
  path = os.path.join(cwd, 'dump.spy')
  if os.path.exists(path):
    sf = False
    dump = '/dump.spy'
  else:
    sf = True
    dump = '/cgi-bin/dump.spy'
]]

<html>
  <head>
    <title>[[= child.title ]]</title>
  </head>

  <body>
    <h1>[[= child.title ]]</h1>
    <hr>

	[[= child._body ]]
    
    <hr>
    <div style="float: right"><b><big>\[[ <font face="arial, helvetica" color="#cc0000">Spyce</font> \]]</big></b></div>
    [[-- the request stack tracks Spyce code contexts: each time a new context loads,
         its filename is pushed onto the stack.  [0] is the original page requested;
         [-1] is the page currently being processed (here, it would be the default
         site template). --]]
    <div><a href=[[= dump ]]?[[= urllib.urlencode([('path', request.stack()[0])]) ]]>Source for this page</a></div>
    [[ for mod, path in L:{ ]]
    <div style="margin-left: 20px"><a href=[[= dump ]]?[[= urllib.urlencode([('path', path)]) ]]>Source for [[= mod ]]</a></div>
    [[ } ]]
    [[ if not sf:{ ]] 
    <div><a href=[[= '/'.join(request.uri().split('/')[:-1]) or '/' ]]>Directory listing</a></div>
    [[ } ]]
    <div><a href=/index.html>Back to the home page</a></div>
  </body>
</html>
