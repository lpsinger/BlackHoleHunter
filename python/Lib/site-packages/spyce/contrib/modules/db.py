from spyceModule import spyceModule

#imports for the database connection pool
import weakref as _weakref
import Queue as _Queue
import thread as _thread

#imports for the loadModleHelper func
import string


class db(spyceModule):
	def start(self):
		if 'db' not in dir(self.server):
			self.server.db = {}
		
	def finish(self, error):
		pass
		
	def set(self, module, host, user, passwd, database, poolsize=10):
		try:
			self.pool = self.server.db[module]
		except:
			pool = _dbpool()
			pool.set_database(_loadModuleHelper(module), poolsize)
			self.server.db[module] = pool
			self.pool = pool
		
		self._host = host
		self._user = user
		self._passwd = passwd
		self._db = database
		self._poolsize = poolsize
		
	def execute(self, query, queryargs=None):
		print "connecting..."
		con = self.pool.connect(\
								host=self._host, \
								user=self._user, \
								passwd=self._passwd, \
								db=self._db \
							   )

		cur = con.cursor()
		cur.execute(query, queryargs) > 0
		try:
			tmp = cur.fetchall() 
		except:
			tmp = None
		cur.close()
		con.close()

		return tmp


#the code here is borrowed from the python documentation (2.3 Built-in functions)
#just because the __import__ function does not return the stuff i want
def _loadModuleHelper(name):
    mod = __import__(name)
    components = string.split(name, '.')
    for comp in components[1:]:
        mod = getattr(mod, comp)
    return mod



 ##################################################################
 # from this point to the end, the code is borrowed from 
 # jon.dbpool module (http://jonpy.sourceforge.net/)
 # 
 # the original dbpool module has encapsulated in a class
 # that's simple and efficient, and do exactly what i need
 ##################################################################
 
 
class _dbpool:
	def __init__(self):
		self.apilevel = "2.0"
		self.threadsafety = 2
		
		self._dbmod = None
		self._lock = _thread.allocate_lock()
		self._refs = {}
				
	def set_database(self, dbmod, minconns):
	  if minconns < 1:
	    raise ValueError, "minconns must be greater than or equal to 1"
	  if self._dbmod is not None:
	    if self._dbmod == dbmod:
	      return
	    raise Exception, "dbpool object is already in use"
	  copy = ("paramstyle", "Warning", "Error", "InterfaceError", "DatabaseError",
	    "DataError", "OperationalError", "IntegrityError", "InternalError",
	    "ProgrammingError", "NotSupportedError")
	  if len(dbmod.apilevel) != 3 or dbmod.apilevel[:2] != "2." or \
	    not dbmod.apilevel[2].isdigit():
	    raise ValueError, "specified database module is not DB API 2.0 compliant"
	  if dbmod.threadsafety < 1:
	    raise ValueError, "specified database module must have threadsafety level" \
	      " of at least 1"
	  self._dbmod = dbmod
	  self._available = {}
	  self._minconns = minconns
	  for v in copy:
	  	self.__dict__[v] = getattr(dbmod, v)

	def connect(self, *args, **kwargs):
	  if self._dbmod is None:
	    raise Exception, "No database module has been specified"
	  try:
	    return self._available[`args` + "\0" + `kwargs`].get(0)
	  except (KeyError, _Queue.Empty):
	    return _Connection(self, None, None, *args, **kwargs)

	def _make_available(self, conn):
	  self._lock.acquire()
	  try:
	    try:
	      self._available[`conn._args` + "\0" + `conn._kwargs`].put(conn, 0)
	    except KeyError:
	      q = _Queue.Queue(self._minconns)
	      q.put(conn, 0)
	      self._available[`conn._args` + "\0" + `conn._kwargs`] = q
	    except _Queue.Full:
	      pass
	  finally:
	    self._lock.release()

	def _connection_notinuse(self, ref):
	  inner = self._refs[ref]
	  del self._refs[ref]
	  inner._cursorref = None
	  if inner._connection is not None:
	    # if the Python interpreter is exiting, _make_available might already have
	    # been deleted, so check for this explicitly:
	    if self._make_available is not None:
	      self._make_available(_Connection(inner))
	

class _Connection:
  def __init__(self, parent, inner, *args, **kwargs):
    self._parent = parent
    if inner is None:
      self._inner = _InnerConnection(parent, *args, **kwargs)
    else:
      self._inner = inner
    self._inner._outerref = _weakref.ref(self)
    ref = _weakref.ref(self, parent._connection_notinuse)
    parent._refs[ref] = self._inner

  def cursor(self, *args, **kwargs):
    # this method would not be necessary (i.e. the __getattr__ would take
    # care of it) but if someone does dbpool.connect().cursor() all in one
    # expression, the outer _Connection class was getting garbage-collected
    # (and hence the actual database connection being put back in the pool)
    # *in the middle of the expression*, i.e. after connect() was called but
    # before cursor() was called. So you could end up with 2 cursors on the
    # same database connection.
    return self._inner.cursor(*args, **kwargs)

  def __getattr__(self, attr):
    return getattr(self._inner, attr)

    
class _InnerConnection:
  def __init__(self, parent, connection, *args, **kwargs):
    self._parent = parent
    self._args = args
    self._kwargs = kwargs
    if connection is None:
      self._connection = parent._dbmod.connect(*args, **kwargs)
    else:
      self._connection = connection
    self._cursorref = None
    self._outerref = None
    self._lock = _thread.allocate_lock()

  def close(self):
    if self._cursorref is not None:
      c = self._cursorref()
      if c is not None:
        c.close()
    self._cursorref = None
    self._outerref = None
    conn = self._connection
    self._connection = None
    self._parent._make_available(_Connection(self._parent, None, conn, *self._args, **self._kwargs))

  def __getattr__(self, attr):
    return getattr(self._connection, attr)

  def cursor(self, *args, **kwargs):
    self._lock.acquire()
    try:
      if self._cursorref is None or self._cursorref() is None:
        c = _Cursor(self, *args, **kwargs)
        self._cursorref = _weakref.ref(c)
        return c
    finally:
      self._lock.release()
    return connect(*self._args, **self._kwargs).cursor(*args, **kwargs)


class _Cursor:
  def __init__(self, connection, *args, **kwargs):
    self._connection = connection
    self._outer = connection._outerref()
    self._cursor = connection._connection.cursor(*args, **kwargs)
  
  def close(self):
    self._connection._cursorref = None
    self._connection = None
    self._cursor.close()
    self._outer = None

  def __getattr__(self, attr):
    return getattr(self._cursor, attr)
