"""
A module for scheduling arbitrary callables to run at given times
or intervals, modeled on the naviserver API.  Scheduler runs in
its own thread; callables run in this same thread, so if you have
an unusually long callable to run you may wish to give it its own
thread, for instance,

schedule(3600, lambda: threading.Thread(target=longcallable).start())

Scheduler does not provide subsecond resolution.

Public functions are threadsafe.
"""

import atexit
import sys
import threading
import time

import spyceUtil

def schedule(interval, callable, once=False):
    """
    Schedules callable to be run every interval seconds.
    Returns the scheduled Task object.
    """
    if interval < 1:
        raise Exception("Interval must be postitive")
    return _insertsorted(Task(time.time() + interval, interval, callable, once))

def schedule_daily(hours, minutes, callable, once=False):
    """
    Schedules callable to be run at hours:minutes every day.
    (Hours is a 24-hour format.)
    Returns the scheduled Task object.
    """
    if hours > 23 or hours < 0:
        raise Exception("Invalid hours")
    if minutes > 59 or minutes < 0:
        raise Exception("Invalid minutes")
    t = list(time.localtime(time.time()))
    t[3] = hours
    t[4] = minutes
    s = time.mktime(t)
    if s < time.time():
        s += 24 * 3600
    return _insertsorted(Task(s, 24 * 3600, callable, once))

def unschedule(task):
    """
    Removes the given task from the scheduling queue.
    """
    _qlock.acquire()
    try:
        _queue.remove(task)
    finally:
        _qlock.release()

class Task:
    """
    Instantiated by the schedule methods.
    
    Instance variables:
      nextrun: epoch seconds at which to run next
      interval: seconds before repeating
      callable: function to invoke
      last: if True, will be unscheduled after nextrun

    (Note that by manually setting last on a Task instance, you
    can cause it to run an arbitrary number of times.)
    """
    def __init__(self, firstrun, interval, callable, once):
        self.nextrun = firstrun
        self.interval = interval
        self.callable = callable
        self.last = once

_qlock = threading.RLock()
# (we don't use a Queue object here since we need to do our own locking anyway)
_queue = []

def _insertsorted(task):
    _qlock.acquire()
    i = len(_queue)
    while i > 0:
        if task.nextrun < _queue[i - 1].nextrun:
            break
        i -= 1
    _queue.insert(i, task)
    _qlock.release()
    return task

_keepgoing = True
_paused = False

def _process():
    """True if a task was run"""
    try:
        _qlock.acquire()
        if not len(_queue):
            return False
        if _queue[-1].nextrun > time.time():
            return False
        task = _queue.pop()
    finally:
        _qlock.release()
    try:
        task.callable()
    except Exception:
        sys.stderr.write(spyceUtil.exceptionString())
    if not task.last:
        task.nextrun = max(task.nextrun + task.interval, time.time())
        _insertsorted(task)
    return True

def _loop():
    sleep = False
    while _keepgoing:
        if sleep:
            time.sleep(1)
        if _paused:
            sleep = True
            continue
        sleep = not _process()
    sys.stderr.write("Scheduler thread has stopped\n")

_thread = threading.Thread(target=_loop, name='spyce-scheduler')
_thread.start()

def pause():
    """Temporarily suspend running scheduled tasks"""
    _paused = True
    
def unpause():
    """
    Resume running scheduled tasks.  If a task came due while
    it was paused, it will run immediately after unpausing.
    """
    _paused = True

def _cleanup():
    sys.stderr.write('Waiting for scheduler thread...\n')
    global _keepgoing
    _keepgoing = False
    _thread.join()
    
atexit.register(_cleanup)

# yes, I need more and better tests...  you're welcome to add some :)
if __name__ == "__main__":
    d = {}
    def foo():
        d['test'] = 1
    t = schedule(1, lambda: threading.Thread(target=foo).start(), True)
    print t
    while not d:
        time.sleep(1)
    print d
