##################################################
# SPYCE - Python-based HTML Scripting
# Copyright (c) 2002 Rimon Barr.
#
# Refer to spyce.py
# CVS: $Id: core.py 737 2005-05-19 17:45:20Z jbe $
##################################################

__doc__ = '''Core Spyce tags.'''

from spyceTag import spyceTagLibrary, spyceTagPlus
import spyce, spyceUtil

class tag_parent(spyceTagPlus):
  name = 'parent'
  def syntax(self):
    self.syntaxSingleOnly()
  def begin(self, src=None, **kwargs):
    if not src:
      src = spyce.getServer().config.defaultparent
    if not src:
      raise 'src not specified, and defaultparent not configured'
    if self._api._parent:
      spyce.DEBUG('warning: replacing old parent %s with %s' % (self._api._parent, src))
    filename = spyceUtil.url2file(src, self.getModule('request').filename())
    self._api._parent = (filename, kwargs)
  def export(self):
    return {self.var: self.val}

class tag_print(spyceTagPlus):
  name = 'print'
  def syntax(self):
    self.syntaxSingleOnly()
    self.syntaxNonEmpty('val')
    self.syntaxValidSet('encode', ['false', 'url', 'html'])
  def begin(self, val, encode='html', default=None):
    try: out = str(val)
    except: 
      if default:
        out = str(default)
      else:
        raise
    if encode == 'html':
      out = self.getModule('transform').html_encode(out)
    elif encode == 'url':
      out = self.getModule('transform').url_encode(out)
    self.getOut().write(out)

class tag_let(spyceTagPlus):
  name = 'let'
  exports = 1
  def syntax(self):
    self.syntaxSingleOnly()
    self.syntaxNonEmpty('var')
  def begin(self, var, val):
    self.var = var
    self.val = val
  def export(self):
    return {self.var: self.val}

class tag_if(spyceTagPlus):
  name = 'if'
  conditional = 1
  def syntax(self):
    self.syntaxPairOnly()
  def begin(self, test, var=None):
    return test

# rimtodo: add first, last boolean flag variables
class tag_for(spyceTagPlus):
  name = 'for'
  conditional = 1
  loops = 1
  exports = 1
  def syntax(self):
    self.syntaxPairOnly()
    self.syntaxNonEmpty('items', 'var', 'counter')
  def body(self, _contents):
    return self._iter()
  def begin(self, items, var='item', counter=None):
    self.remaining = items
    try: self.remaining = list(self.remaining)
    except TypeError:
      raise 'items expression should result in sequence, %s is not iterable'%repr(self.remaining)
    self.var = var
    self.counter = counter
    self.i = 0
    return self._iter()
  def export(self):
    d = {}
    if self.var:
      try:
        d[self.var] = self.element
      except: pass
    if self.counter:
      d[self.counter] = self.i
    return d

  def _iter(self):
    # get next
    if not self.remaining: return 0
    self.element, self.remaining = self.remaining[0], self.remaining[1:]
    self.i = self.i + 1
    return 1


# rimtodo: catch
# rimtodo: choose, when, otherwise

class core(spyceTagLibrary):
  tags = [
    tag_parent, 
    tag_print, 
    tag_let, 
    tag_if,
    tag_for,
  ]

